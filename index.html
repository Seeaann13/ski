<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ski-VTuber V10.3 Sandwich Fix</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        
        #ui {
            position: absolute; top: 10px; left: 10px; width: 260px; z-index: 100;
            background: rgba(0, 0, 0, 0.9); color: #00d2ff; padding: 15px; 
            border-radius: 12px; border: 1px solid #00d2ff; font-size: 13px;
        }
        
        label { display: block; margin-top: 5px; color: #fff; font-size: 12px; }
        input[type=range] { width: 100%; accent-color: #00d2ff; margin: 2px 0; }
        .row { display: flex; gap: 5px; }
        
        button { 
            background: #00d2ff; color: #000; border: none; padding: 10px; 
            width: 100%; border-radius: 6px; font-weight: bold; margin-top: 10px;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<canvas id="vtuber-canvas"></canvas>

<div id="ui">
    <div style="text-align:center; font-weight:900; margin-bottom:5px;">V10.3 圖層修復版</div>
    
    <label>1. 位置調整 (X / Y / 大小)</label>
    <div class="row">
        <input type="range" id="p-x" min="-200" max="200" value="0">
        <input type="range" id="p-y" min="-200" max="300" value="100">
    </div>
    <input type="range" id="p-scale" min="0.2" max="2.0" step="0.01" value="0.85">

    <label>2. 物理參數 (風力 / 限制)</label>
    <input type="range" id="p-wind" min="0" max="10" step="0.1" value="2.0">
    
    <button id="btn-start">啟動系統</button>
    <button onclick="document.getElementById('ui').classList.add('hidden')" style="background:#444; color:white;">隱藏</button>
    <div id="status" style="color:#aaa; font-size:10px; text-align:center; margin-top:5px;">等待啟動...</div>
</div>

<script>
    // --- 1. 物理核心 ---
    class PhysicsLayer {
        constructor(name, img, type, z) {
            this.name = name;
            this.img = img;
            this.type = type; // static, head, face, hair
            this.z = z;
            
            this.angle = 0;
            this.velocity = 0;
            this.visible = true;
            this.id = name.split('.')[0]; 

            // 物理材質
            this.mass = 1.0; 
            this.stiffness = 0.08; 
            this.damping = 0.92;
            
            // 根據檔名分配材質
            if (name.includes('_L')) { this.mass = 0.6; this.stiffness = 0.12; }
            if (name.includes('_H')) { this.mass = 3.0; this.stiffness = 0.03; this.damping = 0.90; }
        }

        update(windForce, headAngle) {
            // 靜態物體不動
            if (this.type === 'static') return;

            // ★ 關鍵修復：五官 (Face) 直接鎖死在頭上，不進行物理運算，消除抖動
            if (this.type === 'face') {
                this.angle = headAngle;
                return;
            }

            // 頭部：只有呼吸擺動
            if (this.type === 'head') {
                this.angle = headAngle;
                return;
            }

            // 頭髮：受風力 + 慣性影響
            // 限制最大風力 (Clamp)，防止歪掉
            let effectiveWind = windForce * (2 - this.mass*0.4);
            if (effectiveWind > 0.8) effectiveWind = 0.8 + (effectiveWind - 0.8) * 0.1; // 軟限制

            let targetAngle = effectiveWind;
            // 慣性：頭往左，頭髮往右
            targetAngle += (headAngle * this.mass * 0.8);

            const force = (targetAngle - this.angle) * this.stiffness;
            const acceleration = force / this.mass;
            this.velocity = (this.velocity + acceleration) * this.damping;
            this.angle += this.velocity;
        }
    }

    const canvas = document.getElementById('vtuber-canvas');
    const ctx = canvas.getContext('2d');
    const video = document.createElement('video');
    video.autoplay = true; video.muted = true; video.playsInline = true;
    
    const layers = [];
    let globalTime = 0;

    // --- 2. 檔案清單 (★ Z-Index 重新排序：三明治法) ---
    const fileList = [
        // 最底層：後領 (5)
        {n:'jacket_back.png', t:'static', z:5},
        
        // 身體 (20)：為了蓋住脖子，身體要在頭前面！
        // 如果你的身體圖包含了後領，那上面的 jacket_back 可以拿掉
        {n:'body.png',        t:'static', z:20},

        // 頭部 (10)：脖子在身體後面
        {n:'head.png',        t:'head',   z:10},
        
        // 五官 (25)：要在身體前面
        {n:'ears.png',        t:'face',   z:25}, // 耳朵改為 face 類型，跟隨頭
        {n:'mouth_close.png', t:'face',   z:26, id:'m_close'},
        {n:'mouth_open.png',  t:'face',   z:26, id:'m_open', v:false},
        {n:'eyes_open.png',   t:'face',   z:27, id:'e_open'},
        {n:'eyes_closed.png', t:'face',   z:27, id:'e_closed', v:false},
        
        // 頭髮 (30+)：最上層
        {n:'hair_base.png',   t:'hair',   z:30},
        {n:'hair_H1.png',     t:'hair',   z:31},
        {n:'hair_H2.png',     t:'hair',   z:31},
        {n:'hair_M1.png',     t:'hair',   z:32},
        {n:'hair_M2.png',     t:'hair',   z:32},
        {n:'hair_L1.png',     t:'hair',   z:33},
        {n:'layer-front1.png',t:'hair',   z:35},
        {n:'layer-front2.png',t:'hair',   z:35}
    ];

    // --- 3. 繪圖核心 ---
    function draw() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = window.innerWidth;
        const h = window.innerHeight;

        ctx.clearRect(0,0,w,h);

        // 畫相機
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            const s = Math.max(w / video.videoWidth, h / video.videoHeight);
            ctx.drawImage(video, (w - video.videoWidth*s)/2, (h - video.videoHeight*s)/2, video.videoWidth*s, video.videoHeight*s);
        }

        // 物理計算
        globalTime += 0.05;
        // 風力
        const windVal = parseFloat(document.getElementById('p-wind').value);
        const wind = (windVal * 0.05) + (Math.sin(globalTime * 0.7) * 0.015);
        // 頭部擺動 (呼吸 + 隨機)
        const headAngle = Math.sin(globalTime * 0.5) * 0.03;
        
        // UI 參數
        const scale = parseFloat(document.getElementById('p-scale').value);
        const offX = parseFloat(document.getElementById('p-x').value);
        const offY = parseFloat(document.getElementById('p-y').value);

        // 繪製
        layers.forEach(l => {
            if (!l.visible) return;
            
            // 更新物理 (傳入頭部角度)
            l.update(wind, headAngle);

            ctx.save();
            ctx.translate(w / 2 + offX, h + offY);
            ctx.scale(scale, scale);
            
            // 旋轉支點：設定在頭部下方 (脖子根部)
            // 這樣頭轉動時，脖子根部是不動的
            const pivotY = -l.img.height * 0.25; // 大約是從底部往上 25% 的位置
            
            if (l.type !== 'static') {
                ctx.translate(0, pivotY); 
                ctx.rotate(l.angle);      
                ctx.translate(0, -pivotY);
            }

            ctx.drawImage(l.img, -l.img.width / 2, -l.img.height);
            ctx.restore();
        });

        requestAnimationFrame(draw);
    }

    // --- 4. 資源載入 ---
    async function loadAll() {
        const status = document.getElementById('status');
        let loaded = 0;
        for (let f of fileList) {
            await new Promise(resolve => {
                const img = new Image();
                img.src = f.n;
                img.onload = () => {
                    const l = new PhysicsLayer(f.n, img, f.t, f.z);
                    if (f.id) l.id = f.id; 
                    if (f.v !== undefined) l.visible = f.v;
                    layers.push(l);
                    loaded++;
                    status.innerText = `載入: ${Math.round(loaded/fileList.length*100)}%`;
                    resolve();
                };
                img.onerror = () => resolve(); 
            });
        }
        layers.sort((a,b) => a.z - b.z);
        status.innerText = "準備完成";
        draw(); 
    }

    // --- 5. 表情與啟動 ---
    function toggleFace(part, isOpen) {
        const openId = part === 'mouth' ? 'm_open' : 'e_open';
        const closeId = part === 'mouth' ? 'm_close' : 'e_closed';
        const openL = layers.find(l => l.id === openId);
        const closeL = layers.find(l => l.id === closeId);
        if (openL && closeL) { openL.visible = isOpen; closeL.visible = !isOpen; }
    }

    function autoBlink() {
        toggleFace('eyes', false);
        setTimeout(() => {
            toggleFace('eyes', true);
            setTimeout(autoBlink, Math.random() * 3000 + 2000);
        }, 150);
    }

    document.getElementById('btn-start').onclick = async () => {
        try {
            const vStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            video.srcObject = vStream;
            const aStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const ctx = new AudioContext();
            const ana = ctx.createAnalyser();
            const src = ctx.createMediaStreamSource(aStream);
            const script = ctx.createScriptProcessor(2048, 1, 1);
            src.connect(ana); ana.connect(script); script.connect(ctx.destination);
            
            script.onaudioprocess = () => {
                const data = new Uint8Array(ana.frequencyBinCount);
                ana.getByteFrequencyData(data);
                const vol = data.reduce((a,b)=>a+b) / data.length;
                if (vol > 20) {
                    toggleFace('mouth', true);
                    clearTimeout(window.tT); window.tT = setTimeout(() => toggleFace('mouth', false), 150);
                }
            };
            autoBlink();
            document.getElementById('btn-start').innerText = "運作中";
            document.getElementById('btn-start').style.background = "#55ff55";
        } catch(e) { alert("啟動失敗: " + e.message); }
    };

    window.onload = loadAll;
</script>
</body>
</html>
