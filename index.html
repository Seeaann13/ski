<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Ski-VTuber V12.1 OBS Link</title>
    
    <!-- 1. AI 語音核心 -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web/dist/bundle.min.js"></script>
    <!-- 2. VDO.Ninja API (用於傳送畫面到 OBS) -->
    <script src="https://unpkg.com/@vdo.ninja/vdo.ninja.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; background: #000; }

        /* 導播面板 */
        #ui {
            position: absolute; top: 10px; left: 10px; width: 280px; z-index: 100;
            background: rgba(10, 10, 15, 0.9); color: #00d2ff; padding: 15px; 
            border-radius: 16px; border: 1px solid rgba(0, 210, 255, 0.3);
            backdrop-filter: blur(12px); box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            font-size: 13px; transition: opacity 0.3s;
        }

        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .status-dot { width: 10px; height: 10px; background: #555; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-active { background: #00ff00; box-shadow: 0 0 8px #00ff00; }
        
        /* 訊號條 */
        .meter-box { background: #222; height: 6px; border-radius: 3px; overflow: hidden; margin: 8px 0; }
        #v-meter { width: 0%; height: 100%; background: linear-gradient(90deg, #00d2ff, #00ff99); transition: width 0.05s; }

        label { display: block; color: #aaa; margin-top: 10px; font-size: 11px; font-weight: bold; }
        input[type=range] { width: 100%; accent-color: #00d2ff; margin: 5px 0; cursor: pointer; }

        /* 按鈕群 */
        .btn-group { display: flex; gap: 10px; margin-top: 15px; }
        button { 
            flex: 1; padding: 12px; border: none; border-radius: 8px; 
            font-weight: bold; cursor: pointer; font-size: 12px; color: #fff;
            background: #333; transition: 0.2s;
        }
        #btn-start { background: linear-gradient(135deg, #00d2ff, #0055ff); color: white; }
        #btn-obs { background: linear-gradient(135deg, #ff9900, #ff5500); color: white; }
        
        .hidden { opacity: 0; pointer-events: none; }
        
        /* OBS 連結顯示區 */
        #obs-link-box {
            display: none; margin-top: 10px; padding: 10px; background: #222; 
            border-radius: 8px; word-break: break-all; font-size: 10px; color: #fff;
            border: 1px dashed #666; user-select: text;
        }
    </style>
</head>
<body>

<canvas id="vtuber-canvas"></canvas>

<div id="ui">
    <div class="header">
        <span style="font-weight:900; font-size:15px; letter-spacing:1px;">V12.1 抹茶完全體</span>
        <div><span id="sys-dot" class="status-dot"></span><span id="sys-text" style="font-size:10px;">待機</span></div>
    </div>

    <!-- 語音監測 -->
    <div style="font-size:11px; color:#888;">語音訊號 (AI/頻率):</div>
    <div class="meter-box"><div id="v-meter"></div></div>

    <!-- 參數控制 -->
    <label>位置 X / Y (請依手機調整):</label>
    <div style="display:flex; gap:5px;">
        <input type="range" id="p-x" min="-300" max="300" value="0">
        <input type="range" id="p-y" min="-300" max="400" value="150">
    </div>
    
    <label>縮放 (Scale):</label>
    <input type="range" id="p-scale" min="0.3" max="2.0" step="0.05" value="0.85">

    <label>靈敏度 (Sensitivity):</label>
    <input type="range" id="p-sens" min="0" max="100" value="70">

    <label>物理風力 (Wind):</label>
    <input type="range" id="p-wind" min="0" max="10" step="0.1" value="3.0">

    <!-- 操作按鈕 -->
    <div class="btn-group">
        <button id="btn-start">① 啟動系統</button>
        <button id="btn-obs" disabled>② 傳送 OBS</button>
    </div>
    
    <div id="obs-link-box">
        連結生成中...
    </div>

    <button onclick="document.getElementById('ui').classList.add('hidden')" style="width:100%; margin-top:10px; background:transparent; border:1px solid #444; color:#888;">隱藏介面 (雙擊喚回)</button>
</div>

<script>
// --- [模組 1 結束] ---
// --- 模組 2: 物理引擎與資源管理 ---

    class PhysicsLayer {
        constructor(name, img, type, z) {
            this.name = name; this.img = img; this.type = type; this.z = z;
            this.angle = 0; this.vel = 0; this.acc = 0;
            this.visible = true; this.id = name.split('.')[0];
            
            // 物理屬性預設
            this.mass = 1.0; this.stiffness = 0.1; this.damping = 0.9;
            
            // 根據檔名自動微調物理
            if (name.includes('_L')) { this.mass = 0.6; this.stiffness = 0.15; } // 輕髮
            if (name.includes('_H')) { this.mass = 2.5; this.stiffness = 0.05; this.damping = 0.85; } // 重髮
            if (name.includes('front')) { this.mass = 0.8; this.stiffness = 0.12; } // 瀏海
        }

        update(wind, headSway) {
            // 靜態物體跟隨頭部平移，但不旋轉
            if (this.type === 'static') return;
            
            // 五官與頭部：直接鎖定角度，不進行物理擺盪 (防抖)
            if (this.type === 'head' || this.type === 'face') {
                this.angle = headSway;
                return;
            }

            // 頭髮：物理模擬
            // 目標角度 = 風力 + 頭部慣性
            let target = (wind * (2 - this.mass*0.3)) + (headSway * this.mass * 0.5);
            
            // 彈簧公式 F = -kx - cv
            let force = (target - this.angle) * this.stiffness;
            let acc = force / this.mass;
            this.vel = (this.vel + acc) * this.damping;
            this.angle += this.vel;
        }
    }

    // 全域變數
    const canvas = document.getElementById('vtuber-canvas');
    const ctx = canvas.getContext('2d');
    const layers = [];
    let globalTime = 0;
    
    // 串流變數
    const video = document.createElement('video');
    video.autoplay = true; video.muted = true; video.playsInline = true;

    // ★ 關鍵圖層順序 (Z-Index)
    const fileList = [
        {n:'jacket_back.png', t:'static', z:5},  // 後領 (底層)
        {n:'head.png',        t:'head',   z:10}, // 頭/脖子 (中間)
        {n:'body.png',        t:'static', z:20}, // 身體/前領 (蓋住脖子)
        
        {n:'ears.png',        t:'head',   z:25},
        {n:'mouth_close.png', t:'face',   z:26, id:'m_close'},
        {n:'mouth_open.png',  t:'face',   z:26, id:'m_open', v:false},
        {n:'eyes_open.png',   t:'face',   z:27, id:'e_open'},
        {n:'eyes_closed.png', t:'face',   z:27, id:'e_closed', v:false},
        
        {n:'hair_base.png',   t:'hair',   z:30},
        {n:'hair_H1.png',     t:'hair',   z:31},
        {n:'hair_H2.png',     t:'hair',   z:31},
        {n:'hair_M1.png',     t:'hair',   z:32},
        {n:'hair_M2.png',     t:'hair',   z:32},
        {n:'hair_L1.png',     t:'hair',   z:33},
        {n:'layer-front1.png',t:'hair',   z:40},
        {n:'layer-front2.png',t:'hair',   z:40}
    ];

    // --- 繪圖迴圈 ---
    function draw() {
        // 設定高畫質
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = window.innerWidth;
        const h = window.innerHeight;

        ctx.clearRect(0,0,w,h);

        // 1. 畫相機背景
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            const s = Math.max(w/video.videoWidth, h/video.videoHeight);
            ctx.drawImage(video, (w-video.videoWidth*s)/2, (h-video.videoHeight*s)/2, video.videoWidth*s, video.videoHeight*s);
        }

        // 2. 計算全域物理
        globalTime += 0.05;
        const windVal = parseFloat(document.getElementById('p-wind').value);
        // 自然風場 (隨機擾動)
        const wind = (windVal * 0.02) + (Math.sin(globalTime * 0.7) * 0.01) + (Math.sin(globalTime * 2.3) * 0.005);
        // 頭部呼吸擺動
        const headSway = Math.sin(globalTime * 0.5) * 0.03;

        const scale = parseFloat(document.getElementById('p-scale').value);
        const offX = parseFloat(document.getElementById('p-x').value);
        const offY = parseFloat(document.getElementById('p-y').value);

        // 3. 繪製圖層
        layers.forEach(l => {
            if (!l.visible) return;
            l.update(wind, headSway);

            ctx.save();
            // 移動到螢幕底部中央
            ctx.translate(w/2 + offX, h + offY);
            ctx.scale(scale, scale);

            // ★ 關鍵：錨點修正 (Anchor Fix) ★
            // 將旋轉中心移到圖片頂部往下約 70% 處 (你的頭部位置)
            // 這樣旋轉時，頭頂就不會位移，只有髮尾會動
            const pivotY = -l.img.height * 0.7; 
            
            if (l.type !== 'static') {
                ctx.translate(0, pivotY); // 移到頭頂
                ctx.rotate(l.angle);      // 旋轉
                ctx.translate(0, -pivotY);// 移回來
            }

            // 畫圖 (以底部中心為基準)
            ctx.drawImage(l.img, -l.img.width/2, -l.img.height);
            ctx.restore();
        });

        requestAnimationFrame(draw);
    }
// --- 模組 3: 雙軌 AI 語音偵測引擎 ---

    let audioContext = null;
    let talkTimer = null;

    // 表情控制函數 (通用)
    function setFace(part, isOpen) {
        const oId = part === 'mouth' ? 'm_open' : 'e_open';
        const cId = part === 'mouth' ? 'm_close' : 'e_closed';
        const op = layers.find(l => l.id === oId);
        const cl = layers.find(l => l.id === cId);
        if (op && cl) { op.visible = isOpen; cl.visible = !isOpen; }
    }

    // --- AI 模式 (主方案) ---
    async function startVAD() {
        try {
            const vFill = document.getElementById('v-meter');
            const statusDot = document.getElementById('sys-dot');
            const statusText = document.getElementById('sys-text');
            
            statusText.innerText = "AI 加載中...";
            
            // 建立 VAD 實例
            const myVAD = await vad.MicVAD.new({
                onFrameProcessed: (probs) => {
                    const sens = 1.0 - (parseFloat(document.getElementById('p-sens').value) / 100);
                    vFill.style.width = (probs.isSpeech * 100) + "%";

                    if (probs.isSpeech > sens) {
                        setFace('mouth', true);
                        if (talkTimer) clearTimeout(talkTimer);
                        talkTimer = setTimeout(() => setFace('mouth', false), 150);
                    }
                }
            });

            myVAD.start();
            statusDot.classList.add('status-active');
            statusText.innerText = "AI 運作中";
            console.log("AI 語音偵測引擎啟動成功！");
            return true; // 成功啟動

        } catch (err) {
            console.error("AI 引擎啟動失敗:", err);
            return false; // 啟動失敗
        }
    }

    // --- 頻率模式 (備援方案) ---
    async function startFallbackFFT() {
        console.warn("AI 啟動失敗，自動降級至頻率偵測模式。");
        
        const statusDot = document.getElementById('sys-dot');
        const statusText = document.getElementById('sys-text');
        const vFill = document.getElementById('v-meter');
        
        statusText.innerText = "備援模式";
        
        if (!audioContext) audioContext = new AudioContext();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioContext.createMediaStreamSource(stream);
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);

        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        function processAudio() {
            analyser.getByteFrequencyData(dataArray);
            
            // 只計算人聲頻段的能量 (過濾風聲)
            let vocalEnergy = 0;
            for (let i = 5; i < 60; i++) { // ~200Hz to ~5kHz
                vocalEnergy += dataArray[i];
            }
            
            const avgEnergy = vocalEnergy / 55;
            vFill.style.width = Math.min(avgEnergy * 1.5, 100) + "%";
            
            // 靈敏度閥值
            const threshold = parseFloat(document.getElementById('p-sens').value) / 2;

            if (avgEnergy > threshold) {
                setFace('mouth', true);
                if (talkTimer) clearTimeout(talkTimer);
                talkTimer = setTimeout(() => setFace('mouth', false), 150);
            }
            requestAnimationFrame(processAudio);
        }
        
        processAudio();
        statusDot.classList.add('status-active');
    }
// --- 模組 4: 系統啟動器與 OBS 傳送門 ---

    // 隨機眨眼循環
    function startBlinkLoop() {
        const nextBlink = Math.random() * 4000 + 2000;
        setTimeout(() => {
            setFace('eyes', false);
            setTimeout(() => {
                setFace('eyes', true);
                startBlinkLoop();
            }, 150);
        }, nextBlink);
    }

    // 主啟動按鈕
    document.getElementById('btn-start').onclick = async () => {
        const btn = document.getElementById('btn-start');
        const obsBtn = document.getElementById('btn-obs');
        btn.innerText = "正在初始化...";
        btn.disabled = true;

        try {
            // 1. 啟動背景相機
            const vStream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } 
            });
            video.srcObject = vStream;
            await video.play();

            // 2. 載入 16 層圖層
            await loadAll();

            // 3. 嘗試啟動 AI，若失敗則自動降級
            const aiSuccess = await startVAD();
            if (!aiSuccess) {
                await startFallbackFFT(); // 啟動備援模式
            }

            // 4. 啟動眨眼
            startBlinkLoop();

            // 5. 正式開始繪圖
            draw();

            btn.innerText = "系統運作中";
            btn.style.background = "#55ff55";
            obsBtn.disabled = false; // 解鎖 OBS 按鈕
            
            // 5 秒後自動隱藏 UI
            setTimeout(() => {
                document.getElementById('ui').classList.add('hidden');
            }, 5000);

        } catch (e) {
            alert("啟動錯誤: " + e.message);
            btn.disabled = false;
            btn.innerText = "啟動失敗 - 重試";
        }
    };

    // --- ★★★ OBS 傳送門 (VDO.Ninja) ★★★ ---
    document.getElementById('btn-obs').onclick = () => {
        const obsBtn = document.getElementById('btn-obs');
        const linkBox = document.getElementById('obs-link-box');
        
        obsBtn.innerText = "連線中...";
        obsBtn.disabled = true;

        // 1. 從 Canvas 抓取畫面串流 (純淨畫面，無UI)
        const canvasStream = canvas.captureStream(30); // 30 FPS

        // 2. 建立 VDO.Ninja 實例
        const ninja = new VDO.Ninja();
        ninja.push(canvasStream);

        // 3. 監聽 Push 連結
        ninja.addEventListener("push", (e) => {
            const pushLink = e.push;
            linkBox.innerHTML = `<b>傳送此連結給你朋友:</b><br>${pushLink}`;
            linkBox.style.display = "block";
            obsBtn.innerText = "已連線到 OBS";
            obsBtn.style.background = "#ff9900";
            
            // 將聲音也傳送過去 (如果需要)
            if (audioContext && audioContext.destination.stream) {
                ninja.push(audioContext.destination.stream);
            }
        });

        ninja.addEventListener("error", () => {
            alert("VDO.Ninja 連線失敗");
            obsBtn.disabled = false;
        });

        ninja.connect();
    };


    // 高畫質適配
    function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
    }
    window.onresize = setupCanvas;
    window.onload = setupCanvas;

    // 雙擊喚回 UI
    document.body.ondblclick = (e) => {
        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
            document.getElementById('ui').classList.toggle('hidden');
        }
    };
</script>
</body>
</html>
