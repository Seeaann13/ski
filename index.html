<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ski-VTuber V11.0 Matcha Edition</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        
        #ui {
            position: absolute; top: 10px; left: 10px; width: 260px; z-index: 100;
            background: rgba(0, 0, 0, 0.85); color: #00ffcc; padding: 15px; 
            border-radius: 12px; border: 1px solid #00ffcc; font-size: 13px;
        }
        input[type=range] { width: 100%; accent-color: #00ffcc; margin: 5px 0; }
        button { background: #00ffcc; color: #000; border: none; padding: 10px; width: 100%; border-radius: 5px; font-weight: bold; margin-top: 10px; }
        .hidden { display: none !important; }
        .bar-container { width: 100%; height: 10px; background: #333; margin-top: 5px; border-radius: 5px; overflow: hidden; }
        #voice-bar { width: 0%; height: 100%; background: #00ffcc; transition: width 0.1s; }
    </style>
</head>
<body>

<canvas id="vtuber-canvas"></canvas>

<div id="ui">
    <div style="text-align:center; font-weight:900; margin-bottom:5px;">V11.0 抹茶聲紋版</div>
    
    <label>1. 聲音過濾 (抗風切):</label>
    <div class="bar-container"><div id="voice-bar"></div></div>
    <div style="font-size:10px; color:#aaa;">(綠條超過閥值才會張嘴)</div>
    
    <label>靈敏度 (Sensitivity):</label>
    <input type="range" id="p-sens" min="1" max="100" value="50">

    <label>2. 物理風力 (Wind):</label>
    <input type="range" id="p-wind" min="0" max="10" step="0.1" value="2.0">
    
    <label>3. 位置調整 (X / Y / Scale):</label>
    <input type="range" id="p-x" min="-200" max="200" value="0">
    <input type="range" id="p-y" min="-200" max="300" value="100">
    <input type="range" id="p-scale" min="0.2" max="2.0" step="0.01" value="0.85">

    <button id="btn-start">啟動系統 (抗噪模式)</button>
    <button onclick="document.getElementById('ui').classList.add('hidden')" style="background:#444; color:white;">隱藏介面</button>
</div>

<script>
    // --- 1. 物理核心：改用 Skew (斜切) ---
    class PhysicsLayer {
        constructor(name, img, type, z) {
            this.name = name; this.img = img; this.type = type; this.z = z;
            
            // 物理狀態 (改為計算 skew 偏移量)
            this.skew = 0;      // 斜切角度
            this.offsetX = 0;   // 水平位移
            this.velocity = 0;
            this.visible = true;
            this.id = name.split('.')[0]; 

            // 物理材質
            this.mass = 1.0; this.stiffness = 0.1; this.damping = 0.85;
            
            // 根據你的分層邏輯設定材質
            if (name.includes('_L')) { // 輕髮 (飄得快)
                this.mass = 0.5; this.stiffness = 0.15; this.damping = 0.90;
            }
            if (name.includes('_H')) { // 重髮 (飄得慢)
                this.mass = 3.0; this.stiffness = 0.05; this.damping = 0.80;
            }
            if (name.includes('front')) { // 瀏海 (靈動)
                this.mass = 0.8; this.stiffness = 0.12; this.damping = 0.88;
            }
        }

        update(windForce, headMovement) {
            if (this.type === 'static') return;
            if (this.type === 'face') { this.offsetX = headMovement * 20; return; } // 五官跟著頭平移
            if (this.type === 'head') { this.offsetX = headMovement * 20; return; } // 頭部平移

            // 頭髮物理：目標是風力 + 頭部慣性
            // 使用 Skew (斜切) 來模擬飄動，而不是旋轉
            let targetSkew = windForce * (1.5 - this.mass * 0.2);
            
            // 慣性：頭往左移，頭髮會因為慣性先往右歪
            targetSkew -= headMovement * this.mass * 2;

            // 彈簧公式
            const force = (targetSkew - this.skew) * this.stiffness;
            const acc = force / this.mass;
            this.velocity = (this.velocity + acc) * this.damping;
            this.skew += this.velocity;
            
            // 頭髮除了歪，還會稍微跟著頭移動 (根部跟隨)
            this.offsetX = headMovement * 20; 
        }
    }

    const canvas = document.getElementById('vtuber-canvas');
    const ctx = canvas.getContext('2d');
    const video = document.createElement('video');
    video.autoplay = true; video.muted = true; video.playsInline = true;
    const layers = []; let globalTime = 0;

    // --- 2. 檔案清單 (依照你的截圖) ---
    const fileList = [
        {n:'jacket_back.png', t:'static', z:5},
        {n:'body.png',        t:'static', z:10}, // 身體蓋住後領
        {n:'head.png',        t:'head',   z:20}, // 頭在身體後面(脖子)
        {n:'ears.png',        t:'head',   z:21}, 
        {n:'mouth_close.png', t:'face',   z:22, id:'m_close'},
        {n:'mouth_open.png',  t:'face',   z:22, id:'m_open', v:false},
        {n:'eyes_open.png',   t:'face',   z:23, id:'e_open'},
        {n:'eyes_closed.png', t:'face',   z:23, id:'e_closed', v:false},
        {n:'hair_base.png',   t:'hair',   z:25},
        {n:'hair_H1.png',     t:'hair',   z:26},
        {n:'hair_H2.png',     t:'hair',   z:26},
        {n:'hair_M1.png',     t:'hair',   z:27},
        {n:'hair_M2.png',     t:'hair',   z:27},
        {n:'hair_L1.png',     t:'hair',   z:28},
        {n:'layer-front1.png',t:'hair',   z:30},
        {n:'layer-front2.png',t:'hair',   z:30}
    ];

    // --- 3. 繪圖核心 (Skew 變形) ---
    function draw() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = window.innerWidth;
        const h = window.innerHeight;
        ctx.clearRect(0,0,w,h);

        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            const s = Math.max(w/video.videoWidth, h/video.videoHeight);
            ctx.drawImage(video, (w-video.videoWidth*s)/2, (h-video.videoHeight*s)/2, video.videoWidth*s, video.videoHeight*s);
        }

        globalTime += 0.05;
        const windVal = parseFloat(document.getElementById('p-wind').value);
        // 風力亂流
        const wind = (windVal * 0.01) + (Math.sin(globalTime * 0.5) * 0.005) + (Math.sin(globalTime * 2.1) * 0.002);
        // 頭部左右平移 (不再是旋轉)
        const headMove = Math.sin(globalTime * 0.5) * 0.05; 
        
        const scale = parseFloat(document.getElementById('p-scale').value);
        const offX = parseFloat(document.getElementById('p-x').value);
        const offY = parseFloat(document.getElementById('p-y').value);

        layers.forEach(l => {
            if (!l.visible) return;
            l.update(wind, headMove);

            ctx.save();
            // 移到中心
            ctx.translate(w/2 + offX, h + offY);
            ctx.scale(scale, scale);

            // ★ 關鍵物理變形：使用 transform 矩陣做 Skew
            // context.transform(hScale, vSkew, hSkew, vScale, hMove, vMove)
            // 我們只動 hSkew (水平斜切) 和 hMove (水平位移)
            
            if (l.type === 'hair') {
                // 頭髮：根據物理計算斜切 + 跟隨頭部平移
                ctx.transform(1, 0, l.skew, 1, l.offsetX, 0);
            } else if (l.type === 'head' || l.type === 'face') {
                // 頭和臉：只平移，不斜切
                ctx.translate(l.offsetX, 0);
            }
            
            // 畫圖 (以底部中心為基準)
            ctx.drawImage(l.img, -l.img.width/2, -l.img.height);
            ctx.restore();
        });
        requestAnimationFrame(draw);
    }

    // --- 4. 資源載入 ---
    async function loadAll() {
        let loaded = 0;
        for (let f of fileList) {
            await new Promise(r => {
                const img = new Image(); img.src = f.n;
                img.onload = () => {
                    const l = new PhysicsLayer(f.n, img, f.t, f.z);
                    if (f.id) l.id = f.id; if (f.v !== undefined) l.visible = f.v;
                    layers.push(l); loaded++; r();
                };
                img.onerror = () => { console.log("缺: "+f.n); r(); };
            });
        }
        layers.sort((a,b) => a.z - b.z);
        draw();
    }

    // --- 5. 表情 ---
    function toggleFace(part, isOpen) {
        const openId = part==='mouth'?'m_open':'e_open';
        const closeId = part==='mouth'?'m_close':'e_closed';
        const o = layers.find(l=>l.id===openId);
        const c = layers.find(l=>l.id===closeId);
        if(o&&c){ o.visible=isOpen; c.visible=!isOpen; }
    }
    function autoBlink() {
        toggleFace('eyes', false);
        setTimeout(() => {
            toggleFace('eyes', true);
            setTimeout(autoBlink, Math.random()*3000+2000);
        }, 150);
    }

    // --- 6. 聲音頻譜分析 (抗風切核心) ---
    document.getElementById('btn-start').onclick = async () => {
        try {
            const vStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            video.srcObject = vStream;
            const aStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            const ctx = new AudioContext();
            const ana = ctx.createAnalyser();
            const src = ctx.createMediaStreamSource(aStream);
            const script = ctx.createScriptProcessor(2048, 1, 1);
            
            // 設定 FFT 大小
            ana.fftSize = 512; 
            src.connect(ana); ana.connect(script); script.connect(ctx.destination);
            
            const voiceBar = document.getElementById('voice-bar');
            const sensSlider = document.getElementById('p-sens');

            script.onaudioprocess = () => {
                const data = new Uint8Array(ana.frequencyBinCount);
                ana.getByteFrequencyData(data);
                
                // ★ 頻率過濾核心 ★
                // 陣列索引 0~5 代表極低頻 (風聲、轟隆聲)，我們直接忽略
                // 我們只計算索引 6 (約250Hz) 到 100 (約4000Hz) 的能量
                let vocalEnergy = 0;
                let count = 0;
                for (let i = 6; i < 100; i++) {
                    vocalEnergy += data[i];
                    count++;
                }
                const avgVol = vocalEnergy / count;
                
                // 視覺化音量條
                voiceBar.style.width = Math.min(avgVol * 2, 100) + "%";

                // 觸發門檻 (Sensitivity)
                const threshold = 105 - parseInt(sensSlider.value); // 數值越小越靈敏
                
                if (avgVol > threshold) {
                    toggleFace('mouth', true);
                    clearTimeout(window.talkT);
                    window.talkT = setTimeout(() => toggleFace('mouth', false), 150);
                }
            };
            autoBlink();
            document.getElementById('btn-start').innerText = "系統運作中";
            document.getElementById('btn-start').style.background = "#55ff55";
        } catch(e) { alert("啟動失敗: " + e.message); }
    };

    window.onload = loadAll;
</script>
</body>
</html>
