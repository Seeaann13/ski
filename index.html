const canvas = document.getElementById('vtuber-canvas');
    const ctx = canvas.getContext('2d');
    const layers = [];
    let globalTime = 0;
    let talkTimer = null;

    class PhysicsLayer {
        constructor(name, img, type, z) {
            this.name = name; this.img = img; this.type = type; this.z = z;
            this.angle = 0; this.vel = 0; this.visible = true; this.id = name.split('.')[0];
            this.mass = name.includes('_H') ? 3.0 : (name.includes('_L') ? 0.6 : 1.0);
            this.stiffness = name.includes('_H') ? 0.04 : 0.1;
            this.damping = 0.9;
        }
        update(wind, headSway) {
            if (this.type === 'static' || this.type === 'head' || this.type === 'face') {
                this.angle = headSway; return;
            }
            let target = (wind * (2 - this.mass*0.3)) + (headSway * this.mass * 0.5);
            // 物理限位：防止頭髮飛出
            const limit = 0.3;
            if (target > limit) target = limit + (target - limit) * 0.2;
            if (target < -limit) target = -limit + (target + limit) * 0.2;
            
            this.vel = (this.vel + (target - this.angle) * this.stiffness) * this.damping;
            this.angle += this.vel;
        }
    }

    async function loadResources() {
        for (let f of fileList) {
            const img = new Image(); img.src = f.n + "?v=" + Date.now();
            await new Promise(r => { 
                img.onload = () => {
                    const l = new PhysicsLayer(f.n, img, f.t, f.z);
                    if (f.id) l.id = f.id; if (f.v !== undefined) l.visible = f.v;
                    layers.push(l); r();
                };
                img.onerror = r; 
            });
        }
        layers.sort((a,b) => a.z - b.z);
    }

    function draw() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = window.innerWidth; const h = window.innerHeight;
        ctx.clearRect(0,0, w, h);

        globalTime += 0.05;
        const wind = (parseFloat(document.getElementById('p-wind').value) * 0.02) + (Math.sin(globalTime*0.7)*0.01);
        const headSway = Math.sin(globalTime * 0.5) * 0.03;
        const scale = parseFloat(document.getElementById('p-scale').value);
        const offX = parseFloat(document.getElementById('p-x').value);
        const offY = parseFloat(document.getElementById('p-y').value);

        layers.forEach(l => {
            if (!l.visible) return;
            l.update(wind, headSway);
            ctx.save();
            // ★ 核心修正：統一畫布繪製邏輯 ★
            // 1. 移動到畫布中心點
            ctx.translate(w/2 + offX, h/2 + offY);
            ctx.scale(scale, scale);
            
            // 2. 物理支點位移 (2000px 的中心點在 1000)
            // 假設頭部在 2000px 圖的高處 25% (即 500px)
            const pivotY = -l.img.height * 0.35; // 調整這個數值來改變旋轉中心
            
            if (l.type !== 'static') {
                ctx.translate(0, pivotY);
                ctx.transform(1, 0, l.angle, 1, 0, 0); // 使用斜切模擬，髮根絕對不動
                ctx.translate(0, -pivotY);
            }
            // 3. 畫出 2000x2000 的圖，使其中心對齊
            ctx.drawImage(l.img, -l.img.width/2, -l.img.height/2);
            ctx.restore();
        });
        requestAnimationFrame(draw);
    }

    function setMouth(state) {
        const c = layers.find(l=>l.id==='m_close'), h = layers.find(l=>l.id==='m_half'), o = layers.find(l=>l.id==='m_open');
        if(c) c.visible = (state===0);
        if(h) h.visible = (state===1);
        if(o) o.visible = (state===2);
    }

    async function startAudio() {
        try {
            const myVAD = await vad.MicVAD.new({
                onFrameProcessed: (probs) => {
                    const sens = document.getElementById('p-sens').value;
                    const halfGate = 1.0 - (sens/100), openGate = halfGate + 0.2;
                    document.getElementById('v-meter').style.width = (probs.isSpeech*100)+"%";
                    document.getElementById('gate-half').style.left = (halfGate*100)+"%";
                    document.getElementById('gate-open').style.left = (Math.min(openGate,1)*100)+"%";

                    if (probs.isSpeech > openGate) { setMouth(2); resetTimer(); }
                    else if (probs.isSpeech > halfGate) { setMouth(1); resetTimer(); }
                }
            });
            myVAD.start();
        } catch (e) { startFallback(); }
    }

    function resetTimer() {
        if(talkTimer) clearTimeout(talkTimer);
        talkTimer = setTimeout(() => { setMouth(1); setTimeout(()=>setMouth(0), 100); }, 150);
    }

    document.getElementById('btn-start').onclick = async () => {
        document.getElementById('btn-start').innerText = "載入中...";
        const sID = document.getElementById('stream-id').value; 
        document.getElementById('ninja-bg').src = `https://vdo.ninja/?view=${sID}&room=sss&solo&autoplay=1&cleanoutput=1&transparent=0&playsinline=1&cover=1`;
        await loadResources();
        await startAudio();
        setInterval(() => { 
            const o = layers.find(l=>l.id==='e_open'), c = layers.find(l=>l.id==='e_closed');
            if(o&&c){ o.visible=false; c.visible=true; setTimeout(()=>{o.visible=true;c.visible=false;},150); }
        }, Math.random()*3000+2000);
        draw();
        document.getElementById('btn-start').style.background = "#55ff55";
        document.getElementById('btn-start').innerText = "系統運作中";
    };

    document.getElementById('ui-toggle').onclick = () => document.getElementById('ui').classList.toggle('hidden');
    window.onload = () => {
        if (new URLSearchParams(window.location.search).has('obs')) {
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('btn-start').click();
        }
    };
</script>
</body>
            </html>
